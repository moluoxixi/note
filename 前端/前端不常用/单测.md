- render：渲染组件，返回 container 容器 dom 和其他的查询 api

- fireEvent：触发某个元素的某个事件

- createEvent：创建某个事件（一般不用这样创建）

- waitFor：等待异步操作完成再断言，可以指定 timeout

- act：包裹的代码会更接近浏览器里运行的方式

- renderHook：执行 hook,返回一个对象，可以通过 对象.result.current 拿到 hook 返回值

jest 的 api 加上 @testing-libary/react 的这些 api，就可以写任何组件、hook 的单元测试了。

```javascript
// useCount.ts
import { useState } from 'react';

type UseCounterReturnType = [
  count: number, 
  increment: (delta: number) => void, 
  decrement: (delta: number) => void
];

export default function useCounter(initialCount: number = 0): UseCounterReturnType {
  const [count, setCount] = useState(initialCount);

  const increment = (delta: number) => {
    setCount(count => count + delta);
  };

  const decrement = (delta: number) => {
    setCount(count => count - delta);
  };

  return [count, increment, decrement];
}
```

```javascript
//App.test.tsx
import {render,screen,fireEvent, waitFor, renderHook} from '@testing-library/react'
import {act} from 'react-dom/test-utils';
import App from './index.tsx'
import useCount from './useCount'

test('测试名称',()=>{
    const {container} = render(<App />);
    //触发input元素的change事件,并传递value:'a'
    fireEvent.change(container.querySelector('input')!,target:value:'a'})
    
    //等待3秒后,测试p标签的文本是不是open
    await waitFor(() => expect(container.querySelector('p')?.textContent).toBe('open'), {
        timeout: 3000
    });
    
    const hook = renderHook(() => useCounter(0));
    const [count, increment, decrement]  = hook.result.current;
    act(() => {
      increment(2);
    });
    expect(hook.result.current[0]).toBe(2);
})
```