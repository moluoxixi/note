# 代码实现
## 部分属性触发 watch
```js
//以下实现,如果对象中多个属性同时改变会反复触发,此时需要一个变量作为标志,避免重复调用

create(){
	const exclundekeys = ['traceId', 'duration', 'servicePort', 'searchKey'];  
	Object.keys(this.searchData).forEach(key => {  
	  !exclundekeys.includes(key) && this.$watch(`searchData.${key}`, () => this.log());  
	});
}

//or chai'yong

watch: {  
  filterData: {  
    async handler(v) {  
      const exclundekeys = ['traceId', 'duration', 'servicePort', 'searchKey'];  
      if (!this.oldFilterData) this.oldFilterData = { ...v };  
      let change = false;  
      for (const key of Object.keys(v)) {  
        if (!exclundekeys.includes(key) && this.oldFilterData[key] != v[key]) {  
          change = true;  
          break;  
        }  
      }  
      if (change) {  
	    await this.$nextTick(async () => {  
		  await this.log();  
		  this.oldFilterData = { ...this.filterData };  
	    });
	  } 
    },  
    deep: true,  
    immediate: true  
  },
}
```

## 防止打开控制台

```javascript
(function() {
    var re = /x/;
    var count = 0;
    var startTime = performance.now();
    console.log(re); // 首次打印
    // 设置断点
    debugger;
     
    re.toString = function() {
        var endTime = performance.now();
        // 设置一个阈值，例如100毫秒
        if (endTime - startTime > 100)window.location.href = 'about:blank';
    };  
})();
```

## 监控网络状态

```javascript
created () {
  //监听navigator状态变化
  if(navigator)navigator.connection.onchange =this.navigatorChange
},
navigatorChange(){
  if(!navigator)return;
  this.onLine=navigator.onLine //是否在线
  this.effectiveType=navigator.connection.effectiveType //网络类型,例如4g
}
```

## 非空检测
```js
function isEmpty(value) {  
    let status=false;  
    // 直接检查null、undefined、空字符串""  
    if (value == null || value === "") status=true;  
  
    // 检查空数组[]  
    if (Array.isArray(value) && value.length === 0) status=true;  
  
    // 对于对象，我们只检查它是否不是null且不是空对象{}（注意：这不会检查嵌套对象）  
    if (typeof value === 'object' && value !== null && Object.keys(value).length === 0) status=true;  
  
    // 如果以上都不是，则认为值不为空  
    return status;  
}
```
## arr to tree

```javascript
let arrData = [
  { id: 1, title: "1", pid: 0, isLeaf: false, children: [] },
  { id: 11, title: "1-1", pid: 1, isLeaf: false, children: [] },
  { id: 111, title: "1-1-1", pid: 11, isLeaf: true, children: [] },
];
// #region 双for,2O复杂度
// function transferTree(list) {
//   var map = {};
//   var result = [];
//   list.forEach((item) => {
//     map[item.id] = item;
//   });
//   list.forEach((item) => {
//     let parent = map[item.pid];
//     if (parent) {
//       if (!parent.children) {
//         parent.children = [];
//       }
//       parent.children.push(item);
//     } else {
//       result.push(item);
//     }
//   });
//   return result;
// }
// console.log(transferTree(arrData));
```

## tree to arr

```javascript
function transferArr(list,arr=[]) {
  list.forEach((item) => {
    if(item.children){
      transferArr(item.children,arr);
    }
    arr.push(item.id);
  });
  return arr;
}
const arr=transferArr(你要转换的树);
数组.filter(i=>arr.includes(i.id))
```

## 复制函数

```javascript
const copyhandler = async (jsonValue, toJSON = false) => {
  function copyToClipboard(text) {
    var textArea = document.createElement('textarea');
    // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域

    textarea.readOnly = 'readonly';

    textarea.style.position = 'absolute';

    textarea.style.left = '-9999px';
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      var successful = document.execCommand('copy');
      if(!successful)return new Error('复制失败');
    } catch (err) {
      return new Error(`复制失败：${err}`);
    }

    document.body.removeChild(textArea);
  }
  try {
    const copyData = toJSON ? JSON.stringify(jsonValue) : jsonValue;
    if (navigator?.clipboard?.writeText) {
      await navigator.clipboard.writeText(copyData);
    } else {
      copyToClipboard(copyData);
    }
    this.$message.success('复制成功');
  } catch (e) {
    this.$message.error('复制失败');
  }
};
```

## 过滤特殊字符

```javascript
function removeInvisibleChars(str) {
    // 替换空白字符（空格、制表符、换行符等）
    str = str.replace(/\s/g, '');
    
    // 替换零宽度空格等特殊字符
    // 这里直接使用Unicode码点匹配
    str = str.replace(/[\u200B-\u200D\uFEFF]/g, '');
    
    // 替换ASCII控制字符（0x00-0x1F）和删除（0x7F）
    str = str.replace(/[\x00-\x1F\x7F]/g, '');
    
    return str;
}

// 示例字符串
var exampleStr = "Hello\u200B World!";
console.log(removeInvisibleChars(exampleStr));  // 打
```

## 文件预览(pdf/图片等)

```javascript
//正常预览链接
//<a href="path/to/your/file.pdf" target="_blank">预览PDF文件</a>
```

## 控制请求并发

关键点在于用一个变量算现在的请求数量

```javascript
export class RequestQueue {
  constructor(maxConcurrent = 3, maxRetries = 3) {
    this.maxConcurrent = maxConcurrent; //最大并发数
    this.maxRetries = maxRetries;       //最大错误重试次数
    this.queue = [];                    //请求等待队列
    this.currentRequests = 0;           //当前并发数
    this.reqSuccessCount=1;             //成功请求的次数
    this.logList=[]
    this.hasBreak=false;
  }
  // 添加 请求 到 请求等待队列
  enqueue(requestFunc,requestParams, requestAfterHandler,retryCount = 0) {
    this.queue.push({ requestFunc,requestParams,requestAfterHandler, retryCount });
    this.processQueue();
  }
  setLogList(logList){
    this.logList=logList
  }
  setHasBreak(){
    this.hasBreak=true;
  }
  onError(error){
    console.error('超过最大重试次数:', error);
    this.setHasBreak();
  }
  setOnError(fn){
    this.onError=fn;
  }
  setStatus(status){
    this.status=status;
  }

  // 处理队列中的请求
  async processQueue() {
    while (this.currentRequests < this.maxConcurrent && this.queue.length > 0&&!this.hasBreak) {
      this.currentRequests++;
      const { requestFunc,requestParams,requestAfterHandler, retryCount } = this.queue.shift();
      try {
        const res=await requestFunc(requestParams); // 假设requestFunc是一个返回Promise的函数
        
        //扩展 请求之后处理的功能
        const req={...requestParams,reqSuccessCount:this.reqSuccessCount}
        requestAfterHandler && requestAfterHandler({req,res}); // 请求成功，调用 requestAfterHandler 回调函数
        this.reqSuccessCount+=1; //放在最后面,防止自定义的requestAfterHandler报错导致total计算错误
        //扩展 添加进度日志-成功日志
        const { reqSuccessCount,chunkCount }=req;
        if(chunkCount&&reqSuccessCount&&this.logList?.length){
          if(chunkCount&&reqSuccessCount){
            this.logList.push({message:`正在${this.status||'请求'}中,进度${reqSuccessCount}/${chunkCount}`})
            if(reqSuccessCount==chunkCount) {
              this.logList.push({ message: `${this.status||'请求'}完毕`, isSuccess: true })
            }
          }
        }
        
      } catch (error) {
        //扩展 添加进度日志-失败日志
        if (retryCount < this.maxRetries) {
          const message=`请求失败,正在进行第 (${retryCount + 1}/${this.maxRetries})次重试...`
          this.logList.push({message,isError:true,error})
          console.log(`请求失败,正在进行第 (${retryCount + 1}/${this.maxRetries})次重试...`,error);
          // 重新将请求（带有递增的重试次数）添加到队列末尾
          this.enqueue(requestFunc,requestParams,requestAfterHandler, retryCount + 1);
        } else {
          const message='超过最大重试次数:'
          this.logList.push({message,isError:true,error})
          requestAfterHandler && requestAfterHandler({req,error}); // 请求失败，传递错误信息
          this.onError(error);
          break;
        }
      } finally {
        this.currentRequests--;
        this.processQueue(); // 递归调用以处理更多请求
      }
    }
  }
}
```

```javascript
// 使用示例：
const queue = new RequestQueue(2, 3); // 最多同时发送2个请求，最大重试次数为3

// 假设fetchData是一个返回Promise的函数，用于发送网络请求
const fetchData = (url) => fetch(url).then(response => response.json());

// 添加请求到队列
queue.enqueue(fetchData,'https://api.example.com/data1');
```

## 大文件上传

文件上传一般有两种方式,fromData和base64 base64可跨平台。但是会比之前的文件大三分之一。导致请求很慢，不适合大文件上传 formData文件流形式可以上传额外信息，当然也可以上传多个文件，适合大文件上传

```javascript
// 引入SparkMD5库  
import SparkMD5 from 'spark-md5';
import {RequestQueue} from '@/utils' //见文件下载,控制请求并发
  
class FileChecksumCalculator {  
    constructor(file, chunkSize) {  
        this.file = file;  
        this.totalSize = file.size;
        this.chunkSize = chunkSize || 1024 * 1024 * 5; // 默认5MB的块大小 
        this.chunkCount = Math.ceil(this.totalSize / this.chunkSize);
        this.currentIndex = 0;//当前请求成功的最后
        this.chunks = [];
    }
  
    //文件合并
        //我们上传的每个chunk端会用特殊命名存起来,例如chunk-唯一值-hash值
        //前端调用合并接口后,后端根据文件的md5值,将所有chunk合并到一块存到数据库
    requstAfterHandler({req:{reqSuccessCount},res}){
        if(reqSuccessCount>=this.chunkCount){
            this.mergeHandler() //模拟的函数
        }
    }
    setRequstAfterHandler(fn){
        const requstAfterHandler=this.requstAfterHandler;
        this.requstAfterHandler=(params)=>{
            requstAfterHandler.call(this,params);
            fn.call(this,params)
        }
    }
    //切片上传
    //利用文件对象的slice和size方法,将文件分成一段一段的小片存在数组中
    createChunks(requestFunc,requestParams={}) {
        try {
            // 计算分片数
            const { chunkSize,totalSize, chunkCount } = this;
            for (let index = 0; index < chunkCount; index++) {
                const start = chunkSize * index;
                const end = Math.min(chunkSize * (index+1), totalSize);
                this.chunks.push(this.file.slice(start, end));
                requestFunc({...requestParams,index,start,end,chunkSize,chunkCount},this.requstAfterHandler.bind(this))
            }
        } catch (error) {
            console.error('Error downloading file:', error);
        }
    }
    //断点续传
        //调用校验接口,约定接口返回断开的下标或者未上传的chunk
    
    //秒传
        //将整个文件md5加密,将加密后的md5串传给后端,后端校验是否存在这个md5串,存在就返回特殊状态,前端直接状态改成已上传
​
    //由于大文件比较大,直接整个一起加密,容错率低,一般一块一块的加密,最终输出结果
        //一般使用SparkMD5包,npm i -S spark-md5
    getMd5() {
        const chunks = this.chunks;
        return new Promise((resolve, reject) => {
            const spark = new SparkMD5.ArrayBuffer();
            //一片一片的读取文件内容,最终生成md5
            readChunk(0);
            
            function readChunk(i) {
                if (i >= chunks.length) {
                    const md5 = spark.end();
                    resolve(md5);
                    return;
                }
    
                const blob = chunks[i];
                const reader = new FileReader();
                reader.readAsArrayBuffer(blob);
    
                reader.onload = (e) => {
                    const bytes = e.target.result;
                    spark.append(bytes);
                    readChunk(i + 1);
                };
    
                reader.onerror = () => {
                    reject(new Error('Error reading file chunk'));
                };
            }
        });
    }
    
    async upload({requstAfterHandler,requestFunc,maxConcurrent = 5, maxRetries = 3, ...requestParams}){
        if(RequestQueue&&requestFunc){
            const queue = new RequestQueue(maxConcurrent, maxRetries); // 最多同时发送5个请求，最大重试次数为3
            if(requstAfterHandler)this.setRequstAfterHandler(requstAfterHandler); //请求之后要干啥的回调
            //args接收{...requestParams,index,start,end,chunkSize,chunkCount},requstAfterHandler
            this.createChunk((...args)=>queue.enqueue(requestFunc,...args),requestParams);
            return this.getMd5()
        }else{
            return new Error('请先引入控制并发函数')        
        }
    }
}
```

```javascript
// 使用示例
<Input type="file" @change="hanleInputChange" />
hanleInputChange= async (e) => {  
  const file = e.target.files[0];  
  if (file) {  
    const calculator = new FileChecksumCalculator(file);
    try {
      //请求函数&请求之后做的事
      const requestFunc = (...req)=>{}
      const requstAfterHandler=function ({req:{total,chunkCount}}){}
      const requestParams={requestFunc,requestAfterHandler,...一些请求参数}
      
      //注意,虽然相同文件内容两次计算出来的md值相同,但是如果这个文件被压缩了,zip也是一种加密算法,这时候两个zip算出来的md5值会不一样
      const md5 =  await calculator.upload(requestParams)
      console.log('File MD5:', md5);  
      // 发送MD5到服务器进行验证等操作...
    } catch (error) {  
      console.error('Error calculating MD5:', error);  
    }  
  }
};
```

## 文件下载

注意,需要指定接口的 `responseType: 'blob'`

```javascript
function downFile (blobs,type,fileName) {
  let blob;
  if(Array.isArray(blobs)){
      blob=blobs;  
  }else if(blobs.type=='application/json'){
      this.$message.error('下载文件失败')
      return JSON.parse(blobs);
  }else{
      blob=[blobs]
  }
  // 2. 使用Blob对象
  const blobData = new Blob(blob, { type });
  // 3. 使用URL.createObjectURL()
  const downloadUrl = URL.createObjectURL(blobData);

  // 4. 触发文件下载
  const downloadLink = document.createElement('a');
  downloadLink.href = downloadUrl;
  downloadLink.download = fileName;
  document.body.appendChild(downloadLink);
  downloadLink.click();
  document.body.removeChild(downloadLink);

  // 释放URL资源
  URL.revokeObjectURL(downloadUrl);
}
```

[fileStream](https://developer.mozilla.org/zh-CN/docs/Web/API/FileSystemFileHandle/createWritable)

```javascript
//只支持https
async function downFile(blobs, type, fileName) {
  // 创建一个新句柄
  const options = {
    suggestedName: 'aaa.zip', // 使用 .bin 扩展名来表示二进制文件
    types: [
      {
        description: "支持的文件格式",
        accept: { "application/zip": [".zip"] },
      },
    ],
  }
  const newHandle = await window.showSaveFilePicker(options)

  // 创建一个 FileSystemWritableFileStream 用于写入
  const writableStream = await newHandle.createWritable()

  // 按顺序写入每个 blob
  let totalWritten = 0
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i]
    await writableStream.write({ type: 'write', position: totalWritten, data: blob })
    totalWritten += blob.size
  }

  // 关闭文件并将内容写入磁盘
  await writableStream.close()
}

```

## 分片下载

利用了控制请求并发,和文件上传的downFile

```javascript
import {downFile,RequestQueue} from '@/utils' //见文件下载,控制请求并发
export class ChunkedDownloader {
  constructor({ totalSize, chunkSize = 1024 * 1024,fileName,fileType }) {
    this.totalSize = typeof totalSize=='function'?totalSize():totalSize;
    this.chunkSize = chunkSize;
    this.chunkCount = Math.ceil(totalSize / chunkSize);
    this.fileName=fileName;
    this.fileType=fileType;
    this.mergeChunk = [];
  }
  setDownHandler(fn){
    this.downFile=fn
  }
  downFile(...args){
      downFile(...args)  
  }
  setRequstAfterHandler(fn){
    const requstAfterHandler=this.requstAfterHandler;
    this.requstAfterHandler=(params)=>{
      requstAfterHandler.call(this,params);
      fn.call(this,params)
    }
  }
  requstAfterHandler({req:{index,reqSuccessCount},res}){
    if(reqSuccessCount<this.chunkCount){
      this.mergeChunk[index]=res;
    }else{
      this.mergeChunk[index]=res;
      this.downFile(this.mergeChunk,this.fileType,this.fileName)
    }
  }
  createChunks(requestFunc,requestParams={}) {
    try {
      // 计算分片数
      const { chunkSize,totalSize, chunkCount } = this;
      for (let index = 0; index < chunkCount; index++) {
        const start = chunkSize * index;
        const end = Math.min(chunkSize * (index+1), totalSize);
        requestFunc({...requestParams,index,start,end,chunkSize,chunkCount},this.requstAfterHandler.bind(this))
      }
    } catch (error) {
      console.error('Error downloading file:', error);
    }
  }
  beackRequest(){
    this.queue?.setHasBreak()
    this.queue=null
  }
  down ({requestAfterHandler, requestFunc,logList,maxConcurrent = 5, maxRetries = 3, ...requestParams }) {
    if(RequestQueue){
      requestAfterHandler&&this.setRequstAfterHandler(requestAfterHandler);
      //提供控制并发功能
      const queue = new RequestQueue(maxConcurrent, maxRetries) // 最多同时发送5个请求，最大重试次数为3
      queue.setStatus('下载');
      logList&&queue.setLogList(logList);
      this.queue=queue;
      this.createChunks((...args) => queue.enqueue(requestFunc, ...args), requestParams)
    }
  }
}
```

示例

```javascript
import {ChunkedDownloader,RequestQueue,downFile} from '@/utils/index'
//准备参数
const fileName = `${productName}_${productVersion}.zip`
const fileType = 'application/zip'
const chunkSize = 10 * 1024 * 1024 //5M
const totalSize= 100 * 1024 * 1024 //100M
//请求函数&请求之后做的事
const requestFunc = (...req)=>{}
const requstAfterHandler=function ({req:{total,chunkCount}}){}

//分片下载
const ChunkedDownloaderParams={fileName, fileType, chunkSize,  totalSize }
const chunkedDown = new ChunkedDownloader(ChunkedDownloaderParams)

//logList是自定义的日志信息
const requestParams={logList:this.logList,requestFunc,requestAfterHandler,...一些请求参数}
this.chunkedDown=chunkedDown;
chunkedDown.down(requestParams)

this.chunkedDown.brackRequest() //取消请求
```

## 权限管理

```
//router.options一般是VueRouter(options)的options
//缓存静态路由
const staticRoutes = router.options.routes;
​
const addRoutes=(routes=[],parentPath = '')=>{
    //还原初始化的静态路由
    router.options.routes = staticRoutes;
    routes.forEach(item => {
        if(item.children){
            addRoutes(item.children,route.path + '/');
        }else{
            item.path=parentPath+item.path
            router.addRoute(item);
        }
    });
}
​
const initRoutes=(router)=>{
    const newRouter = new VueRouter();
    router.matcher = newRouter.matcher;
}
//例如现在退出登录
initRoutes(router);
​
//例如现在登录拿到了动态路由asyncRoutes
addRoutes(asyncRoutes);
​
//route的来源来自于路由守卫,路由守卫中判断,在跳转登录页时,缓存from路由信息作为route
let route={};
router.beforeEach(form,to,next)=>{
    if(to.path==='\login'){
        route=form||{};
    }
    return hasPermission(router,to)?next():next('/login');
}
​
//登录完毕后如果需要重定向到之前的页面,需要判断是否还存在权限
const hasPermission=(router,route)=>{
    const routes=router.matcher.options.routes; //3.0x
    //const routes=router.getRoutes() //4.0x
    const hasRoute=(item,route)=>{
        //路由匹配规则
        const matchRule=item.path===route.path||item.name===route.name;
        //如果有子路由,则匹配子路由和当前路由,否则只匹配当前路由
        return item.children?item.children.find(el=>hasRoute(el,route)||matchRule:matchRule;
    }
    return routes.find(el=>hasRoute(el,route));
}
hasPermission(router,route);
//可以在路由守卫中通过next跳转,也可以通过router.replace跳转
```

## 冒泡排序原理

- 两相邻的数依次比较

- 若从小到大排列两两比较时前一个数比后一个数大互换位置

- 相互比较完一轮最大的数就会到最后面，并且不再参与比较

- 循环比较 直到比较完成

## 冒泡排序步骤

1. 确定外层循环次数   数组的长度

1. 确定内层循环的次数  每确定冒泡一个数内层循环减少一次 数组长度 减 外层循环的index

1. 相邻两数相比较  前一个数比后一个数大 互换两数位置

## 冒泡排序代码实现

```
var a = [36,26,27,2,4,19,50,48];
var temp;
​
for(var i= 0; i <  a.length; i++)
for(var j = 0; j < a.length-i; j++){
    if(a[j] >  a[j+1]){
        temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
    }
}
console.log(a);
```

## 选择排序原理

- 找未排序的元素中最小的数

- 将最小数与起始位置互换

- 直到排序完成

## 选择排序步骤

1. 确定外层循环次数 index为每一次寻找最小值的起始位置 直到数组长度

1. 内层循环每次都是由起始位置 +1 直到数组长度

1. 假设每一次的起始位置为最小数 碰到更小的用更小的和后面的数继续做比较

1. 保存最小数的索引

1. 内层循环结束后最小数与起始位置互换

## 选择排序代码实现

```
var a = [4,12,13,4,3,42,33,4,43,44];
var temp;
var minIndex;
​
for(var i = 0; i < a.length; i ++){
    minIndex = i;
    for(var j = i + 1; j < a.length; j++){
        if(a[minIndex] > a[j]){
            minIndex = j;
        }
    }
    temp = a[minIndex];
    a[minIndex] = a[i];
    a[i] = temp;
}
console.log(a);
```

## 快排

```
 let arr = [1, 5, 3, 7, 6, 8, 12, 0];
  function quick(ary) {
    //1.判断传入的数组长度，如果是一个就直接返回
    if (ary.length <= 1)return ary;
    //2.如果长度不为1，那么就取数组的中间值
    let contentIndex = Math.floor(ary.length / 2);
    let contentValue = ary.splice(contentIndex, 1)[0];
    //3.先定义左右两个数组，然后让数组中剩余的数与中间数进行比较，比中间数小的放到左边的数组，比中间数大的放到右边的数组。
    let leftArr = [],rightArr = [];
    for (let item of arr) {
      item > contentValue ? rightArr.push(item) : leftArr.push(item);
    }
    //4.使用递归的方式让左右两边的数组持续这样处理，直至左右两边的数组都排好序，最后三者进行拼接
    return quick(leftArr).concat([contentValue], quick(rightArr));
  }
  arr = quick(arr);
  console.log(arr);
```

## 小驼峰

```
/**
 * 说明：
 *   写个转换函数，把一个JSON对象的key从下划线形式（Pascal）转换到小驼峰形式（Camel）
 * 示例：
 *   converter({"a_bc_def": 1}); // 返回 {"aBcDef": 1}
 */
function converter(inputObject) {
  if (typeof inputObject !== 'object' || inputObject === null) {
    return inputObject;
  }
​
  const result = {};
​
  Object.keys(inputObject).forEach((key) => {
    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    result[camelKey] = converter(inputObject[key]);
  });
​
  return result;
}
​
const input = { "a_bc_def": 1 };
const output = converter(input);
console.log(output); // 输出 { "aBcDef": 1 }
​
 
​
​
​
​
function converter(obj) {
    const getCamelKey=(key)=>key.split('_').reduce((p,c)=>p+`${c[0].toUpperCase()}${c.slice(1,c.length)}`,'');
  const entriesObj=Object.entries(obj);
  entriesObj.forEach(el=>el[0]=getCamelKey(el[0]))
  return Object.fromEntries(entriesObj);
}
console.log(converter({"a_bc_def": 1}));
```

## add-柯里化

```
function add(...rest) {
  let res=0;
  const fn=(...newRest)=>{
    //没有参数,返回结果
    if(!newRest.length)return res;
    //有参数,返回函数
    res=newRest.reduce((p,c)=>p+c,res);
    return fn;
  };
  fn.valueOf,fn.toString=()=> res;
  return fn(...rest);
}
​
console.log(add(1)(2)(3)());
console.log(add(1)(2)(3)+'');
console.log(add(1)(2)(3)==6);
```

## 

## 手写flat

```
//不使用数组的 arr.flat() API，自己实现一个数组拍平函数，需要支持任意层级
function flat(list, depth=1,arr=[]) {
  if(!Array.isArray(list)||!depth){
    arr.push(list);
    return;
  }
  for(let item of list){
    flat(item,depth-1,arr);
  }
  return arr;
}
​
​
​
//GPT
function flattenArray(arr, depth = 1) {
  if (depth === 0) {
    return arr;
  }
​
  const result = [];
​
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      result.push(...flattenArray(item, depth - 1));
    } else {
      result.push(item);
    }
  });
​
  return result;
}
​
const nestedArray = [1, [2, [3, 4, [5, 6]], 7], 8];
​
const flatArray = flattenArray(nestedArray, 2);
console.log(flatArray); // 输出 [1, 2, 3, 4, 5, 6, 7, 8]
```

## 循环依赖

```
//实现一个方法，检查一个 npm 包的依赖项中有没有存在循环依赖。
​
//不用考虑版本，只考虑包名即可
//入参 pkgs 为项目中所有的依赖（包括子依赖）
//返回 boolean
//pkg 数据结构即为 package.json 内容的数组
​
function hasCircularDependencies(pkgs) {
  const visited = new Set();
  const inProgress = new Set();
​
  function hasCycle(pkg) {
    if (inProgress.has(pkg.name)) {
      return true; // 循环依赖
    }
    if (!visited.has(pkg.name)) {
      inProgress.add(pkg.name);
      if (pkg.dependencies) {
        for (const depName in pkg.dependencies) {
          const dep = pkgs.find((p) => p.name === depName);
          if (dep && hasCycle(dep)) {
            return true;
          }
        }
      }
      inProgress.delete(pkg.name);
      visited.add(pkg.name);
    }
    return false;
  }
​
  for (const pkg of pkgs) {
    if (hasCycle(pkg)) {
      return true;
    }
  }
​
  return false;
}
​
const packages = [
  {
    name: "a",
    dependencies: {
      b: "^1.0.0",
    },
  },
  {
    name: "b",
    dependencies: {
      c: "^1.0.0",
    },
  },
  {
    name: "c",
    dependencies: {
      a: "^1.0.0",
    },
  },
];
​
const hasCircular = hasCircularDependencies(packages);
console.log(hasCircular); // 输出 true（存在循环依赖）
```

## uuid

```javascript
uuid(len = 16, radix = 16) {
  var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
  var uuid = [],
      i;
  radix = radix || chars.length;

  if (len) {
    // Compact form
    for (i = 0; i < len; i++) uuid[i] = chars[0 | (Math.random() * radix)];
  } else {
    // rfc4122, version 4 form
    var r;

    // rfc4122 requires these characters
    uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
    uuid[14] = '4';

    // Fill in random data.  At i==19 set the high bits of clock sequence as
    // per rfc4122, sec. 4.1.5
    for (i = 0; i < 36; i++) {
      if (!uuid[i]) {
        r = 0 | (Math.random() * 16);
        uuid[i] = chars[i == 19 ? (r & 0x3) | 0x8 : r];
      }
    }
  }

  return uuid.join('');
},
```

## deepClone

```javascript
function deepClone(obj, Attr = null, replaceAttr = null, hash = new WeakMap()) {
  // 对于非对象或数组类型，直接返回
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  // 如果obj是日期或正则对象等特殊对象，则直接返回新对象
  if (obj instanceof Date) {
    return new Date(obj);
  }

  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags);
  }

  // 如果hash中存在该对象，则直接返回，避免循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }

  // 创建一个新的对象或数组
  let clone = Array.isArray(obj) ? [] : {};
  hash.set(obj, clone);

  // 遍历对象的属性
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 否则，递归复制属性值
      clone[key] = deepClone(obj[key], Attr, replaceAttr, hash);
    }
  }
  if (!clone[replaceAttr]) clone[replaceAttr] = clone[Attr]; // 替换为新的值

  // 返回克隆的对象或数组
  return clone;
}
```

## 三角形与矩阵生成

```javascript
//目前只支持,正三角形元素齐全的时候准确排列,和矩形正常排列
fn(nodeCount) {
  function calculateTrianglePositions(nodes, nodeWidth, nodeHeight, containerWidth, center) {
    const positions = [];
    const centerX = containerWidth / 2; // 容器中心x坐标
    //偶数逻辑
    if (nodes % 2 === 0) {
      let cols = Math.ceil(Math.sqrt(nodes)); //每行个数
      let level = 1; // 当前层数，从1开始
      let xOffset = centerX - Math.floor(cols / 2) * nodeWidth; // 当前层的x坐标偏移量
      let yOffset = 0; // 当前层的y坐标偏移量
      let currentIndex = 0; //当前层的第几个元素
      for (let i = 0; i < nodes; i++) {
        // 如果当前节点数超过了当前层的节点数，则进入下一层
        if (currentIndex === cols) {
          // eslint-disable-next-line no-unused-vars
          level++; // 层数递增
          yOffset += 10;
          currentIndex = 0;
        }
        // 计算当前节点的x坐标（基于偏移量和节点在当前层的位置）
        const x = xOffset + currentIndex * nodeWidth;
        // 计算当前节点的y坐标（基于层数和节点高度）
        const y = yOffset; // 等边三角形排列的y坐标
        currentIndex++;
        positions.push({ x, y });
      }
    } else if (center) {
      //奇数且居中逻辑
      let level = 1; // 当前层数，从1开始
      let xOffset = 0; // 当前层开始排列的第一个元素相对于中间的偏移量
      let yOffset = 0; // 当前层的y坐标偏移量
      let currentIndex = 0; //当前层的第几个元素
      let leftCurrentIndex = 0; //当前层左边添加的几个元素
      let rigthCurrentIndex = 0; //当前层右边添加的第几个元素
      let isOdd = true; //是否是奇数行且为第一个元素
      let isRight = false; //当前是否是在添加右边
      for (let i = 0; i < nodes; i++) {
        // 如果当前节点数超过了当前层的节点数，则进入下一层
        if (currentIndex === level) {
          currentIndex = 0;
          level++; // 层数递增
          isOdd = level % 2 === 1;
          // console.log('奇数', level % 2);
          xOffset = isOdd ? 10 : 5; // 更新x坐标偏移量
          yOffset += 10;
          leftCurrentIndex = 0;
          rigthCurrentIndex = 0;
          // if(overCount<level){
          //
          // }
        }
        let x;
        //天衍四十九,遁去其一,这便是那遁去的一,道爷,你悟了吗
        if (isOdd) {
          // 计算当前节点的x坐标（基于偏移量和节点在当前层的位置）
          x = centerX;
          isOdd = false;
          // console.log('isOdd', x);
        } else {
          if (isRight) {
            x = centerX + xOffset + rigthCurrentIndex * nodeWidth;
            rigthCurrentIndex++;
            // console.log('isRight', x);
          } else {
            x = centerX - xOffset - leftCurrentIndex * nodeWidth;
            leftCurrentIndex++;
            // console.log('isLeft', x, xOffset, leftCurrentIndex);
          }
          isRight = !isRight;
        }
        currentIndex++;
        // 计算当前节点的y坐标（基于层数和节点高度）
        const y = yOffset; // 三角形排列的y坐标
        positions.push({ x, y });
      }
    } else {
      //奇数逻辑
      let level = 1; // 当前层数，从1开始
      let xOffset = 0; // 当前层的x坐标偏移量
      let yOffset = 0; // 当前层的y坐标偏移量
      let currentIndex = 0; //当前层的第几个元素
      for (let i = 0; i < nodes; i++) {
        // 如果当前节点数超过了当前层的节点数，则进入下一层
        if (currentIndex === level) {
          level++; // 层数递增
          xOffset -= 5; // 更新x坐标偏移量
          yOffset += 10;
          currentIndex = 0;
          // if(overCount<level){
          //
          // }
        }
        currentIndex++;
        // 计算当前节点的x坐标（基于偏移量和节点在当前层的位置）
        const x = centerX + xOffset + currentIndex * nodeWidth;
        // 计算当前节点的y坐标（基于层数和节点高度）
        const y = yOffset; // 等边三角形排列的y坐标
        positions.push({ x, y });
      }
    }

    return positions;
  }

  // 示例
  //   const nodeCount = 7; // 节点个数
  const nodeWidth = 10; // 节点宽度
  const nodeHeight = 10; // 节点高度
  const containerWidth = 100; // 容器宽度

  // 打印结果
  // positions.forEach((pos, index) => {
  // console.log(`Node ${index + 1}: (${pos.x}, ${pos.y})`);
  // });
  return calculateTrianglePositions(nodeCount, nodeWidth, nodeHeight, containerWidth, true);
},
```

## aysnc/await

原理是通过generator和promise实现的

```
// 以下是generator+promise实现async/await
// yield相当于await,generator相当于async
  function * generator () {
    // next函数的参数会作为yield表达式的值,即下示fn函数中g.next接收的参数会作为request的参数
    let num1 = yield request(1)
    let num2 = yield request(num1)
    let num3 = yield request(num2)
    let num4 = yield request(num3)
    let num5 = yield request(num4)
    console.log(num1, num2, num3, num4, num5) //2,4,8,16,32
    return 123;
  }
  /**
   * @description - 封装co函数,用于接收generator函数,并自动执行generator
   * @param generator
   */
  function co (generator) {
   if(Object.prototype.toString.call(generator)!=='GeneratorFunction'){
     return new Error('不是generator函数');
   }
    const g = generator()
    function fn (val) {
      const next = g.next(val);
      console.log(next.done?next.value:'')
      // next.done则调用结束,next.value为generator返回值,直接返回即可
      // 若!next.done,则需将promise的值在then中传递给下一个yield表达式
      return next.done?next.value:Promise.resolve(next.value).then(fn);
    }
    fn()
  }
​
  co(generator)
```

线性思维

# codeTop
## 3. 无重复字符的最长子串

[https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1117576/3-wu-zhong-fu-zi-fu-de-zui-chang-zi-chua-au85/](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1117576/3-wu-zhong-fu-zi-fu-de-zui-chang-zi-chua-au85/)

```
var lengthOfLongestSubstring = function (s) {
    const set = new Set(); //判断滑动窗口内是否有重复元素
    let i = 0,//滑动窗口右边界
        j = 0,//滑动窗口左边界
        maxLength = 0;
    if (s.length === 0) {//极端情况
        return 0;
    }
    for (i; i < s.length; i++) {
        if (!set.has(s[i])) {//当前元素不在set中 就加入set 然后更新最大长度，i++继续下一轮循环
            set.add(s[i]);
            maxLength = Math.max(maxLength, set.size);
        } else {
            //set中有重复元素不断让j++ 并删除窗口之外的元素 直到滑动窗口内没有重复的元素
            while (set.has(s[i])) {
                set.delete(s[j]);
                j++;
            }
            set.add(s[i]);//放心将s[i]加入set中
        }
    }
    return maxLength;
};
```

## 88. 合并两个有序数组

```
var merge = function(nums1, m, nums2, n) {
  let p1 = m - 1;
  let p2 = n - 1;
  let p3 = m + n - 1;
  while (p1 >= 0 && p2 >= 0) {
    nums1[p1] > nums2[p2] ? nums1[p3--] = nums1[p1--] : nums1[p3--] = nums2[p2--];
  }
​
  while (p2 >= 0) {
    nums1[p3--] = nums2[p2--];
  }
​
​
};
```

## 415. 字符串相加

```
function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength , 0);//"0009007199254740991"
   b = b.padStart(maxLength , 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i=maxLength-1 ; i>=0 ; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t/10);
      sum = t%10 + sum;
   }
   if(f){
      sum = f + sum;
   }
   return sum;
}
```

## 165. 比较版本号

[https://leetcode.cn/problems/compare-version-numbers/solutions/971101/javascriptban-ben-jian-dan-si-lu-qing-xi-oys2/](https://leetcode.cn/problems/compare-version-numbers/solutions/971101/javascriptban-ben-jian-dan-si-lu-qing-xi-oys2/)

```
var compareVersion = function(version1, version2) {
  let i = 0
  let j = 0
  while(i < version1.length || j < version2.length) {
    let num1 = 0
    let num2 = 0
    // i < version1.length  1.2.3 最后一个没有.
    while(version1[i] != '.' &&  i < version1.length) {
      num1 = version1[i++] - 0 + num1 * 10
    }
    while(version2[j] != '.' && j < version2.length) {
      num2 = version2[j++] - 0 + num2 * 10
    }
    if (num1 > num2) {
      return 1
    } else if (num1 < num2) {
      return -1
    }
    i++
    j++
  }
  return 0
};
```

## 20. 有效的括号

```
var isValid = function(s) {
  let stk = []
  for (let c of s) {
    if (c == '{') stk.push('}');
    else if (c == '[') stk.push(']');
    else if (c == '(') stk.push(')');
    // 1.符号不匹配
    // 2.右符号多 stk.pop() = undefined
    else if (c != stk.pop()) return false;
    
  }
  if (stk.length != 0) return false
  return true
};
```

```
{}()[]((
```

## 1. 两数之和

```
var twoSum = function (nums, target) {
  let map = new Map();
  for (let i = 0; i < nums.length; i++) {
    if ( map.has(nums[i])) return [map.get(nums[i]), i];
    map.set(target - nums[i], i);
  }
};
```

## 46. 全排列 

[https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/](https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/)

[https://leetcode.cn/problems/permutations/solutions/857631/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/?orderBy=hot&languageTags=javascript](https://leetcode.cn/problems/permutations/solutions/857631/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/?orderBy=hot&languageTags=javascript)

```
var permute = function (nums) {
  const res = [];
  const path = [];
  const set = new Set();
  dfs();
  return res;
​
​
  function dfs() {
    if (path.length === nums.length) {
      // Array.from();
      res.push(Array.from(path));
      return;
    }
    for (let i = 0; i < nums.length; i++) {
      if (set.has(nums[i])) continue;
​
      path.push(nums[i]);
      set.add(nums[i]);
      dfs();
​
      set.delete(path.pop());
    }
  }
};
```

## 53. 最大子序和

[https://leetcode-cn.com/problems/maximum-subarray/solution/xiang-xi-jie-du-dong-tai-gui-hua-de-shi-xian-yi-li/](https://leetcode-cn.com/problems/maximum-subarray/solution/xiang-xi-jie-du-dong-tai-gui-hua-de-shi-xian-yi-li/)

```
const maxSubArray = function(nums) {
  let pre = 0
  let max = -Infinity
  for (let i = 0; i < nums.length; i++) {
    pre = Math.max(nums[i], pre + nums[i]) //每个终止点之前的最大序列和
    max = Math.max(max, pre) //各个终止点最大序列和进行对比
  }
  return max
}

```

## 206. 反转链表

```
var reverseList = function(head) {
  let pre = null;
  let cur = head;
  
  while (cur != null) {
  const temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};

```

## 112. 路径总和

```
var hasPathSum = function(root, targetSum) {
  if (root === null) return false;
  return dfs(root, targetSum)

  function dfs(root, targetSum){
    if (!root) return targetSum === 0;
    return dfs(root.left, targetSum - root.val) || dfs(root.right, targetSum - root.val)
  }

};

```

## 102. 二叉树的层序遍历

```
var levelOrder = function(root) {
  if (!root) return [];
  const stak = [root];
  let len = stak.length;
  const res = [];
  let temp = [];
  for (let i = 0; i < len;) {
    let root = stak.shift();
    temp.push(root.val);
    if (root.left) stak.push(root.left);
    if (root.right) stak.push(root.right);
    i++;
    if (i === len) {
      i = 0;
      len = stak.length;
      res.push(temp);
      temp = [];
    } 
  }
  return res;
};

```

##  15. 三数之和 

```
var threeSum = function (nums) {
  let ans = []
  if (nums.length < 3)return ans;
  nums.sort((a, b) => a - b)
  
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > 0) break;
    if (nums[i - 1] == nums[i]) continue;
    //if (nums[i--] == nums[i]) continue;
    let l = i + 1
    let r = nums.length - 1
    while (l < r) {
      if (nums[i] + nums[l] + nums[r] === 0) {
        ans.push([nums[i], nums[l], nums[r]])
        l++
        r--
        while (l < r && nums[l] == nums[l - 1]) l++;
        while (l < r && nums[r] == nums[r + 1]) r--;
     // while (l < r && nums[l] == nums[--l]) l++;
     // while (l < r && nums[r] == nums[++r]) r--;
      } else if (nums[i] + nums[l] + nums[r] < 0) {
        l++
      } else {
        r--
      }
    }
  }
  return ans
};


```

## 70. 爬楼梯

```
// n阶 = （n - 1）阶走一步 + （n - 2) 阶走两步
var climbStairs = function(n) {
  if (n == 1) return 1
  if (n == 2) return 2
  let firstStep = 1
  let secondStep = 2
  let temp
  for (let i = 3; i <= n; i++) {
    temp = secondStep
    secondStep = secondStep + firstStep
    firstStep = temp
  }
  return secondStep
};


```

##  5. 最长回文子串

```
var longestPalindrome = function(s) {
  if (s.length === 0) return '';
  const palindrome = (l, r) => {
    while (l >= 0 && r < s.length) {
      if (s[l] !== s[r]) {
        break;
      }
      l--;
      r++;
    }
    return s.substring(l + 1, r);
  }
  let max = '';
  for (let i = 0; i < s.length; i++) {
    let res1 = palindrome(i, i);
    let res2 = palindrome(i, i + 1);
    max = res1.length > max.length ? res1 : max;
    max = res2.length > max.length ? res2 : max;
  }
  return max;
};

```

## 121. 买卖股票的最佳时机

```
// 不持有/持有股票
// dp[i][0] = max(dp[i-1][0], dp[i - 1][1] + prices[i]);
// dp[0][0] = 0;
// dp[0][1] = -prices[0];
var maxProfit = function(prices) {
  let dp0 = 0;
  let dp1 = -prices[0];
  for (let i = 1; i < prices.length; i++) {
    dp0 = Math.max(dp0, dp1 + prices[i]);
    dp1 = Math.max(-prices[i], dp1);
  }
  return dp0;
};



```

##  215. 数组中的第K个最大

```
var findKthLargest = function (nums, k, start = 0, end = nums.length - 1) {
  //base case one 找到最后一个才找到
  // if (start == end) return nums[k]
  if (start == end) return nums[start];
  let pivotIdx = Math.ceil(Math.random() * (end - start)) + start;
  const pivot = nums[pivotIdx];
  [nums[pivotIdx], nums[end]] = [nums[end], nums[pivotIdx]];
  let i = start;
  // for (let j = 0; j < end; j++) {
  for (let j = start; j < end; j++) {
    if (nums[j] > pivot) {
      [nums[i], nums[j]] = [nums[j], nums[i]];
      i++;
    }
  }
  [nums[end], nums[i]] = [nums[i], nums[end]];

  //base case two 在中间就找到
  if (k == i + 1) {
    return nums[i];
  }
  if (k < i + 1) {
    // return findKthLargest(nums, k, 0, i - 1)
    return findKthLargest(nums, k, start, i - 1);
  } else {
    // return findKthLargest(nums, k, i + 1, nums.length - 1)
    return findKthLargest(nums, k, i + 1, end);
  }
};



```

## 141. 环形链表

```
// 假设有环形
var hasCycle = function(head) {
  // 快慢指针初始化指向 head
  let slow = head;
  let fast = head;
  // 快指针走到末尾时停止
  while (fast && fast.next) {
    // 慢指针走一步，快指针走两步
    slow = slow.next;
    fast = fast.next.next;
    // 快慢指针相遇，说明含有环
    if (slow == fast) {
      return true;
    }
  }
  // 不包含环
  return false;
};

```

##  129. 求根到叶子节点数字

```
// 把null也当成一个节点

var sumNumbers = function (root) {
  const dfs = (root, path) => {
      
    if (root == null) return 0;
    if (!root.left && !root.right) return path * 10 + root.val;
    return dfs(root.left, path * 10 + root.val) + dfs(root.right, path * 10 + root.val);
  };
  return dfs(root, 0);
};



作者：angela
链接：
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

## 排序

```
// 快排
// 时间复杂度 O(nlogn)
// 空间复杂度 O(1)
function qSort(ary, start = 0, end = ary.length - 1) {
  // if (start == end) return ary;
  if (start >= end) return ary; //!==========
  const pivotIdx = Math.floor(Math.random(end - start + 1) + start);
  [ary[pivotIdx], ary[end]] = [ary[end], ary[pivotIdx]];
  const pivot = ary[pivotIdx];
  let i = start;
  for (let j = start; j < ary.length; j++) {
    if (ary[j] < pivot) {
      [ary[i], ary[j]] = [ary[j], ary[i]];
      i++;
    }
  }
  [ary[end], ary[i]] = [ary[i], ary[end]]; //!=====================
  qSort(ary, start, i - 1);
  qSort(ary, i + 1, end);
  return ary;
}

```

```
/**
 * 归并排序
 * 时间复杂度：n*log(n)
 * 空间复杂度：n
 */
function mergeSort(ary) {
  if (ary.length < 2) {
    return ary;
  }
  // 把数组一分为二
  var mid = Math.floor(ary.length / 2);
  var left = ary.slice(0, mid);
  var right = ary.slice(mid);
  // 左边排
  mergeSort(left);
  // 右边排
  mergeSort(right);

  // 合起来
  var i = 0; // 指向left数组
  var j = 0; // 指向right数组
  var k = 0; // 指向结果数组

  if (left.at(-1) > right.at(0)) {
    //同步指针，任意一个数组先遍历完结束
    while (i < left.length && j < right.length) {
      if (left[i] < right[j]) {
        ary[k++] = left[i++];
      } else {
        ary[k++] = right[j++];
      }
    }
  }

  //!  哪一个数组还没遍历完加到结果数组的末尾
  while (i < left.length) {
    ary[k++] = left[i++];
  }
  while (j < right.length) {
    ary[k++] = right[j++];
  }

  return ary;
}

```

```
// 堆排
// 时间复杂度：O(n*log(n))
// 空间复杂度：O(1) 没有创建过数组，没有递归过
function heapSort(ary) {
  heapify(ary);
  for (let i = ary.length - 1; i >= 1; i--) {
    [ary[i], ary[0]] = [ary[0], ary[i]];
    shiftDown(ary, 0, i - 1);
  }
  return ary;
}

function heapify(ary) {
  // >> 1 奇数会减一除以2  偶数直接除以2
  let start = (ary.length - 1) >> 1;
  for (let i = start; i >= 0; i--) {
    shiftDown(ary, i, ary.length - 1);
  }
}

//!  最大堆
function shiftDown(ary, start, end) {
  while (start * 2 + 1 <= end) {
    let i = start * 2 + 1;
    if (i + 1 <= end && ary[i + 1] > ary[i]) {
      i++;
    }
    if (ary[i] > ary[start]) {
      [ary[i], ary[start]] = [ary[start], ary[i]];
      start = i;
    } else {
      break;
    }
  }
}

let a = [9, 8, 7, 6, 5, 4, 3, 2, 1];
heapSort(a);

```

```
//插入排序（Insertion Sort）是一种简单直观的排序算法，它的基本思想是将一个待排序的数组分成两部分：有序部分和无序部分。初始时，有序部分只包含一个元素，无序部分包含除该元素以外的所有元素。排序过程中，每次从无序部分取出一个元素，将它插入到有序部分的合适位置，使得插入后仍然保持有序。重复这个过程，直到无序部分中的元素全部插入到了有序部分，排序完成。
function insertSort(ary) {
  for (let i = 1; i < ary.length; i++) {
    for (let j = i; j > 0; j--) {
      if (ary[j] < ary[j - 1]) {
        swap(ary, j, j - 1);
      } else {
        break;
      }
    }
  }
  return ary;
}

function bubbleSort(ary) {
  let isSwapped = false;
  for (let i = ary.length - 1; i > 0; i--) {
    for (let j = 0; j <= i; j++) {
      if (ary[j] > ary[j + 1]) {
        isSwapped = true;
        swap(ary, j, j + 1);
      }
    }
    if (!isSwapped) {
      break;
    }
  }
  return ary;
}

```

```
// 找出剩下元素中最小的放入i位置
function selectSort(ary) {
  //数组最后一项不用遍历
  for (var i = 0; i < ary.length - 1; i++) {
    var minIdx = i;
    for (var j = i + 1; j < ary.length; j++) {
      if (ary[j] < ary[minIdx]) {
        minIdx = j;
      }
    }
    swap(ary, i, minIdx);
  }
  return ary;
}

```

## 200. 岛屿数量

```
var numIslands = function(grid) {
  let res = 0;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      isIsland(i, j) && res++;
    }
  }
  return res;

  function isIsland(i,j) {
    if (grid[i][j] === '1') {
      sink(i, j);
      return true;
    }
  }


  function sink(i, j) {
    if (i < 0 || i > grid.length - 1 || j < 0 || j > grid[0].length - 1 || grid[i][j] === '0') return;
    grid[i][j] = '0';
    sink(i - 1, j);
    sink(i + 1, j);
    sink(i, j - 1);
    sink(i, j + 1);
  }
};

```

## 21. 合并两个有序链表

```
var mergeTwoLists = function(list1, list2) {
  if (list1 === null) return list2;
  if (list2 === null) return list1;
  let dummy = new ListNode();
  let [p1, p2, p3] = [list1, list2, dummy];
  while(p1 && p2) {
    if (p1.val < p2.val) {
      p3.next = p1; 
      p1 = p1.next;
      p3 = p3.next;
    } else {
      p3.next = p2;
      p2 = p2.next;
      p3 = p3.next;
    }
  }
  // p1存在节点，直接连接
  if (p1) {
    p3.next = p1;
    // p3.next = p1;
    // p1 = p1.next;
    // p3 = p3.next;
  }
  if (p2) {
    p3.next = p2;
    // p3.next = p2; 
    // p2 = p2.next;
    // p3 = p3.next;
  }
  return dummy.next;
};


1 2 3 4
2 3 4 5         



```

##  704. 二分查找

[https://leetcode-cn.com/problems/binary-search/comments/](https://leetcode-cn.com/problems/binary-search/comments/)

```
// （版本二）左闭右开区间
var search = function(nums, target) {
    let l = 0, r = nums.length;
    // 区间 [l, r）
    while(l < r) {
        let mid = (l + r) >> 1;
        if(nums[mid] === target) return mid;
        let isSmall = nums[mid] < target;
        l = isSmall ? mid + 1 : l;
        // 所以 mid 不会被取到
        r = isSmall ? r : mid;
    }
    return -1;
};

```

## 22. 括号生成 brain snap

[https://leetcode-cn.com/problems/generate-parentheses/comments/](https://leetcode-cn.com/problems/generate-parentheses/comments/)

```
var generateParenthesis = function(n) {
  let res = [];
  function dfs(left, right, cur) {
    if (left === 0 && right === 0) {
      res.push(cur);
      return;
    }
    //自动剪枝的二叉树
    if (left > 0) dfs(left - 1, right, cur + '('); // 条件成立，才加左括号
    if (right > left) dfs(left, right - 1, cur + ')'); // 条件成立，才加右括号
  }
  dfs(n, n, '');
  return res;
};

```

## 94. 二叉树的中序遍历

[https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/dong-hua-mo-ni-er-cha-shu-zhong-xu-bian-3lyxb/](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/dong-hua-mo-ni-er-cha-shu-zhong-xu-bian-3lyxb/)

```
var inorderTraversal = function(root) {
  const res = [];
  const stack = [];
  while (root !== null) {
    stack.push(root);
    root = root.left;
  }
  while (stack.length !== 0) {
    root = stack.pop()
    res.push(root.val)
    root = root.right
    while(root !== null) {
      stack.push(root)
      root = root.left
    }
  }
  return res
};


1 3        2142
2 4   

```

## 54. 螺旋矩阵

 [https://leetcode-cn.com/problems/spiral-matrix/solution/tu-jie-zhu-shi-xiang-xi-by-angela-x-gw3u/](https://leetcode-cn.com/problems/spiral-matrix/solution/tu-jie-zhu-shi-xiang-xi-by-angela-x-gw3u/)

```
const spiralOrder = function(matrix) {
  const res = []
  let [top, bottom, left, right] = [0, matrix.length - 1, 0, matrix[0].length - 1]
  while (top < bottom && left < right) {
    for (let i = left; i < right; i++) res.push(matrix[top][i])
    for (let i = top; i < bottom; i++) res.push(matrix[i][right])
    for (let i = right; i > left; i--) res.push(matrix[bottom][i])
    for (let i = bottom; i > top; i--) res.push(matrix[i][left])
    top++
    bottom--
    left++
    right--
  }
  if (bottom == top) {
    for (let i = left; i <= right; i++) res.push(matrix[top][i])
  } else if (left == right) {
    for (let i = top; i <= bottom; i++) res.push(matrix[i][left])
  }
  // if (left == right) {
  //   for (let i = top; i <= bottom; i++) res.push(matrix[i][left])
  // }
  return res
}

```

## 322. 零钱兑换  

 [https://leetcode-cn.com/problems/coin-change/solution/js-xiang-jie-dong-tai-gui-hua-de-si-xiang-yi-bu-da/](https://leetcode-cn.com/problems/coin-change/solution/js-xiang-jie-dong-tai-gui-hua-de-si-xiang-yi-bu-da/)

```
疑问：初始值不是很清楚

```

```
// 当前金额最小硬币数     Math.min(当前金额最小硬币数， 当前金额减一个硬币钱硬币数 + 1)
var coinChange = function(coins, amount) {
  let dp = new Array( amount + 1 ).fill( Infinity );
  dp[0] = 0; // 初始值，没有实际意义
  
  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i - coin >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }
  
  return dp[amount] === Infinity ? -1 : dp[amount];
}



```

## 300. 最长上升子序列

[https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/300-zui-chang-di-zeng-zi-xu-lie-by-chen-w5e0h/](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/300-zui-chang-di-zeng-zi-xu-lie-by-chen-w5e0h/)

```
var lengthOfLIS = function (nums) {
  let res = [nums[0]]
  for(let i = 1; i < nums.length; i++) {
    if(nums[i] > res[res.length - 1]) {
      res.push(nums[i])
    } else {
      let l = 0
      let r = res.length - 1
      while(l < r) {
        let mid = (l + r) >> 1
        if(nums[i] > res[mid]) {
          // 在 mid ~ r 区间查找
          l = mid + 1
        } else {
          // 在 0 ~ mid 区间查找
          r = mid
        }
      }
      // 此时 r = l
      res[r] = nums[i] //将nums[i]插入到递增序列res的正确位置！！！！！！！！！！！！！！！！！！
    }
  }
  return res.length
};

```

## 146. LRU缓存机制

```
class LRUCache {
  constructor(capacity) {
    this.secretKey = new Map();
    this.capacity = capacity;
  }
  get(key) {
    if (this.secretKey.has(key)) {
      let tempValue = this.secretKey.get(key);
      this.secretKey.delete(key);
      this.secretKey.set(key, tempValue);
      return tempValue;
    } else return -1;
  }
  put(key, value) {
    // key存在，仅修改值
    if (this.secretKey.has(key)) {
      this.secretKey.delete(key);
      this.secretKey.set(key, value);
    }
    // key不存在，cache未满
    else if (this.secretKey.size < this.capacity) {
      this.secretKey.set(key, value);
    }
    // 添加新key，删除旧key
    else {
      this.secretKey.set(key, value);
      // 删除map的第一个元素，即为最长未使用的
      this.secretKey.delete(this.secretKey.keys().next().value);
    }
  }
}

```

## 剑指 Offer 22. 链表中倒数

```
// 倒数第三个节点，快指针走两步，平移到末尾


var getKthFromEnd = function(head, k) {
  let fast = head
  let slow = head
	// 走k步 k + 1 个节点
  for (let i = 0; i < k; i++) {
    // k大于链表长度， 或者空链表
    if (fast == null) return null
    fast = fast.next
  }
  while (fast) {
    fast = fast.next
    slow = slow.next
  }
  return slow
};

```

##  104. 二叉树的最大深度

```
var maxDepth = function(root) {
  if (root === null) return 0;
  return Math.max(maxDepth(root.right) + 1, maxDepth(root.left) + 1);
};

```

## 剑指 Offer 10- I. 斐波那契

```
var fib = function(n) {
  if (n < 2) {
    return n;
  }
  let one = 0;
  let two = 1;
  let temp
  for (let i = 2; i <= n; i++) {
    temp = two;
    two = two + one;
    one = temp;
  }
  return two;
};

```

## 56. 合并区间

```
// 画图模拟 [[1,3],[2,6],[8,10],[15,18]]
var merge = function(intervals) {
  //a[0]每个数组的下标为0的数升序排序
  //a[1]每个数组的下标为0的数升序排序
  intervals.sort((a,b) => a[0] - b[0]);
  let ans = []
  for(let i = 0; i < intervals.length; ) {
   
     max = intervals[i][1]
     let j = i + 1 // j和i是每一个区间
    while (j < intervals.length && intervals[j][0] <= max) {
      max = Math.max(max, intervals[j][1]);
      j++
    }
    ans.push([intervals[i][0], max])
    i = j
  }
    return ans
};

```

##  695. 岛屿的最大面积

 [https://leetcode.com/problems/max-area-of-island/discuss/108533/JavaC%2B%2B-Straightforward-dfs-solution](https://leetcode.com/problems/max-area-of-island/discuss/108533/JavaC%2B%2B-Straightforward-dfs-solution)

```
var maxAreaOfIsland = function(grid) {
  let max = 0;
  let area;
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] === 1) {
        area = areaF(i, j, grid);
        max = Math.max(area, max);
      }
    }
  }
  return max;

  function areaF(i, j, grid) {
    if (i < 0 || i >= grid.length - 1 || j < 0 || j >= grid[0].length || grid[i][j] != 1) {
      // 无实际意义
      return 0;
    } 
    let area = 0;
    grid[i][j] = 0;
    return area = areaF(i - 1, j, grid) + areaF(i + 1, j, grid) + areaF(i, j - 1, grid) + areaF(i, j + 1, grid) + 1;
  }
};

```

## 62. 不同路径 

```
疑问：初始值不是很清楚

```

[https://leetcode-cn.com/problems/unique-paths/solution/san-chong-shi-xian-xiang-xi-tu-jie-62-bu-4jz1/](https://leetcode-cn.com/problems/unique-paths/solution/san-chong-shi-xian-xiang-xi-tu-jie-62-bu-4jz1/)

```
// dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
var uniquePaths = function(m, n) {
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(1))
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
};


var uniquePaths = function(m, n) {
  const dp = new Array(n).fill(1)
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
        dp[j] = dp[j - 1] + dp[j]  
    }
  }
  return dp[n - 1]
};

```

##  103. 二叉树的锯齿形层次

```
var zigzagLevelOrder = function(root) {
  let res = [];
  let queue = [];
  if (root != null) {
      queue.push(root);
  }
  let isOrderLeft = true;
  while (queue.length) {
      let n = queue.length;
      let level = [];
      for (let i = 0; i < n; i++) { 
          let node = queue.shift();
          if (isOrderLeft) {
            level.push(node.val)
          } else {
            level.unshift(node.val);
          }
          if (node.left != null) {
              queue.push(node.left);
          }
          if (node.right != null) {
              queue.push(node.right);
          }
      }
      res.push(level);
      isOrderLeft = !isOrderLeft;
  }
  return res;
};

```

##  209. 长度最小的子数组

[https://pic.leetcode-cn.com/1626251110-hOsxXM-209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif](https://pic.leetcode-cn.com/1626251110-hOsxXM-209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

[https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/jin-tian-mei-tu-yi-dong-chuang-kou-xian-zhao-dao-y/](https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/jin-tian-mei-tu-yi-dong-chuang-kou-xian-zhao-dao-y/)

```
var minSubArrayLen = function(target, nums) {
  let [l, min, sum] = [0, Infinity, 0];
  for (let r = 0; r < nums.length; r++) {
    sum += nums[r];
    while (sum >= target) {
      min = Math.min(min, r - l + 1);
      sum -= nums[l];
      l++;
    }
  }
  return min === Infinity ? 0 : min;
};

```

## 718. 最长重复子数组

 [https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zhe-yao-jie-shi-ken-ding-jiu-dong-liao-by-hyj8/](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zhe-yao-jie-shi-ken-ding-jiu-dong-liao-by-hyj8/)

```
// dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。
// dp[i][j] = dp[i - 1][j - 1] + 1
const findLength = function(nums1, nums2) {
  const [m, n] = [nums1.length, nums2.length];
  let max = 0
  let dp = new Array(m + 1).fill(0).map(() => new Array(n + 1))
  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0 || j === 0) {

        dp[i][j] = 0
      } else if (nums1[i - 1] === nums2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
        max = Math.max(max, dp[i][j])
      } else {
        dp[i][j] = 0
      }
    }
  }
  return max
}

const findLength = function(nums1, nums2) {
  const [m, n] = [nums1.length, nums2.length];
  let max = 0
  let dp = new Array(n + 1)
  for (let i = 0; i <= m; i++) {
    for (let j = n; j >= 0; j--) {
      if (i === 0 || j === 0) {
        dp[j] = 0
      } else if (nums1[i - 1] === nums2[j - 1]) {
        dp[j] = dp[j - 1] + 1
        max = Math.max(max, dp[j])
      } else {
        dp[j] = 0
      }
    }
  }
  return max
}

```

## 226. 翻转二叉树

```
var invertTree = function(root) {
  if (root == null) return root
  //交换根节点左右子节点
  let temp = root.left;
  root.left = root.right;
  root.right = temp;
  //翻转根节点的左子节点
  invertTree(root.left)
  //翻转根节点的右子节点
  invertTree(root.right)
  return root
};


var invertTree = function(root) {
  if (root == null) return null
  let queue = []
  queue.push(root)
  while (queue.length) {
    let node = queue.shift() 
    let temp = node.left
    node.left = node.right
    node.right = temp
    if (node.left != null) {
      queue.push(node.left)
    }
    if (node.right != null) {
      queue.push(node.right)
    }
  }
  return root
};

```

## 384. 打乱数组 class类

 [https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-javascript-by-lzxjack-3o5l/](https://leetcode-cn.com/problems/shuffle-an-array/solution/da-luan-shu-zu-javascript-by-lzxjack-3o5l/)

[https://leetcode-cn.com/problems/shuffle-an-array/solution/pythonjavajavascriptgo-xi-pai-suan-fa-by-k7i2/](https://leetcode-cn.com/problems/shuffle-an-array/solution/pythonjavajavascriptgo-xi-pai-suan-fa-by-k7i2/)

```
class Solution {
  constructor(nums) {
    this.nums = nums
    this.original = [...this.nums]
  }
  reset() {
    this.nums = [...this.original]
    return this.nums
  }
  shuffle() {
    for (let i = 0; i < this.nums.length - 1; i++) {
      // const j = i + Math.floor(Math.random() * (this.nums.length - i))
      const j = i + Math.floor(Math.random() * (this.nums.length - i));
      [this.nums[i], this.nums[j]] = [this.nums[j], this.nums[i]]
    }
    return this.nums
  }
}

```

##  144. 二叉树的前序遍历

来自 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/) 

```
1 3    1234
2 4

var preorderTraversal = function(root) {
  let stk = [];
  const res = [];
  let node = root;
  while (node !== null) {
    res.push(node.val);
    stk.push(node);
    node = node.left;
  }
  while (stk.length !== 0) {
    node = stk.pop();
    node = node.right;
    while (node !== null) {
      stk.push(node);
      res.push(node.val);
      node = node.left;
    }
  }
return res;
};



```

## 40

## 2. 两数相加

```
var addTwoNumbers = function(l1, l2) {
  let p1 = l1; 
  let p2 = l2;
  let dummy = new ListNode(-1);
  let p = dummy;
  let carry = 0;
  // 或||写的顺序和循环里面写的顺序一样，短路运算
  while (p1 != null || p2 != null || carry != 0) {
    let val = carry;
    if (p1 != null) {
      val += p1.val;
      p1 = p1.next;
    }
    if (p2 != null) {
      val += p2.val;
      p2 = p2.next;
    }
    carry = Math.floor(val / 10);
    //模十，把1十位去掉，剩下个位
    val = val % 10;
    p.next = new ListNode(val);
    p = p.next
  }
  return dummy.next
};

```

## 14. 最长公共前缀

来自 [https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/](https://leetcode-cn.com/problems/longest-common-prefix/solution/hua-jie-suan-fa-14-zui-chang-gong-gong-qian-zhui-b/) 

```
var longestCommonPrefix = function(strs) {
  let ans = strs[0];
  for (let i = 1; i < strs.length; i++) {
    let j = 0;

  //                 j项数组字符串比前面一项数组长或者短取的并集

    for ( ;j < ans.length && j < strs[i].length; j++) {
      if (strs[i][j] !== strs[0][j]) {
        break
      }
    }
    ans = ans.substring(0, j);
    //当查找到子字符串没有公共前缀，不用再遍历下一项子字符串直接返回结果''
    if (ans === '') return ans;
  }
  return ans
};

```

##  283. 移动零

[https://leetcode.cn/problems/move-zeroes/solution/283-yi-dong-ling-by-chen-wei-f-wxfh/](https://leetcode.cn/problems/move-zeroes/solution/283-yi-dong-ling-by-chen-wei-f-wxfh/)

[https://leetcode-cn.com/problems/move-zeroes/solution/283-yi-dong-ling-by-chen-wei-f-wxfh/](https://leetcode-cn.com/problems/move-zeroes/solution/283-yi-dong-ling-by-chen-wei-f-wxfh/) 

```
var moveZeroes = function(nums) {
  let l = 0;
  for (let r = 0; r < nums.length; r++) {
    if (nums[r] !== 0) {
      [nums[r], nums[l]] = [nums[l], nums[r]];
      l++;
    }
  }
};

```

## 93. 复原IP地址

来自 <[https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/](https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/)

```
const restoreIpAddresses = (s) => { 
  const res = [];
  const dfs = (subRes, start) => {
    if (subRes.length == 4 && start == s.length) {
      res.push(subRes.join('.'));
      return;
    }            
    for (let len = 1; len <= 3; len++) {           
      const str = s.substring(start, start + len); 
      subRes.push(str);                            
      dfs(subRes, start + len);                    
      subRes.pop(); 
    }
  };
};

```

## 155. 最小栈 class类

[https://leetcode-cn.com/problems/min-stack/solution/cun-fang-dui-xiang-javascript-by-lzxjack-oo9i/](https://leetcode-cn.com/problems/min-stack/solution/cun-fang-dui-xiang-javascript-by-lzxjack-oo9i/) 

```
class MinStack {
  constructor() {
    this.stack = [];
  }
  push(val) {
    this.stack.push({
      val,
      min: this.stack.length ? Math.min(this.getMin(), val) : val,
    });
  }
  pop() {
    this.stack.pop();
  }
  getMin() {
    return this.stack[this.stack.length - 1].min;
  }
  top() {
    return this.stack[this.stack.length - 1].val;
  }
}


```

## 105. 从前序与中序遍历序

```
var buildTree = function(preorder, inorder) {
  return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1)

  function build(preorder, preStart, preEnd, inorder, inStart, inEnd) {
    if (preStart > preEnd) return null
       // 黄色部分归在前序遍历
    let rootVal = preorder[preStart]
    let rootIdx
    for (let i = inStart; i <= inEnd; i++) {
      if (inorder[i] == rootVal) {
        rootIdx = i
        break
      }
    }
    let root = new TreeNode(rootVal)
    let leftLen = rootIdx - inStart
    root.left = build(preorder, preStart + 1, preStart + leftLen, inorder, inStart, rootIdx - 1)
    root.right = build(preorder, preStart + leftLen + 1, preEnd, inorder, rootIdx + 1, inEnd) 
   // 后序遍历返回给上一个节点
  return root
  }
};


```

##  剑指 Offer 10- II. 青蛙跳台 brain snap

```
var numWays = function(n) {
  if (n === 0) return 1;
  if (n < 2) return n;
  n1 = 1;
  n2 = 2;
  let temp;
  for (let i = 3; i <= n; i++) {
    temp = n2;
    n2 = (n1 + n2)  % 1000000007;
    n1 = temp;
  }
  return n2;
};

```

## 160. 相交链表 brain snap

[https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/](https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/)

```
var getIntersectionNode = function(headA, headB) {
    let p1 = headA;
    let p2 = headB;
    while (p1 != p2) {
      if (p1 != null) p1 = p1.next;
      else            p1 = headB;
      if (p2 != null) p2 = p2.next;
      else            p2 = headA;
    }
    return p2
};

```

## 19. 删除链表的倒数第N个 实例模拟

[https://leetcode.com/problems/remove-nth-node-from-end-of-list/discuss/8804/Simple-Java-solution-in-one-pass](https://leetcode.com/problems/remove-nth-node-from-end-of-list/discuss/8804/Simple-Java-solution-in-one-pass)

```
var removeNthFromEnd = function(head, n) {
  let dummy = new ListNode(0, head);
  let fast = dummy, slow = dummy;
  // for (let i = 0; i < n; i++) {
  for (let i = 0; i <= n; i++) {
    fast = fast.next;
  }
  while (fast !== null) {
    fast = fast.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  // return head;
  return dummy.next;
};

```

## 64. 最小路径和 动态规划

来自 [https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-dong-tai-gui-hua-gui-fan-liu-c/](https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-dong-tai-gui-hua-gui-fan-liu-c/) 

```
// dp[m][n] = dp[m][n] + Math.min(dp[m - 1][n], dp[m][n - 1]);
// dp[m][n] = dp[m][n] + dp[m - 1][n];
// dp[m][n] = dp[m][n] + dp[m][n - 1];

var minPathSum = function(grid) {
  const [m, n] = [grid.length, grid[0].length]
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (i === 0 && j === 0) continue;
      else if (i === 0) {
        grid[i][j] = grid[i][j] + grid[i][j - 1];
      }
      else if (j === 0) {
        grid[i][j] = grid[i][j] + grid[i - 1][j];
      }
      else {
        grid[i][j] = grid[i][j] + Math.min(grid[i -1][j], grid[i][j - 1]);
      }
    }
  }
  return grid[m -1][n - 1];
};

```

## 43. 字符串相乘

## 48. 旋转图像

来自 [https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/](https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/) 

## 剑指 Offer 62. 圆圈中最后

## 509. 斐波那契数

## 199. 二叉树的右视图

[https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/shen-du-you-xian-sou-suo-by-shetia-2/](https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/shen-du-you-xian-sou-suo-by-shetia-2/)

[https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/shen-du-you-xian-sou-suo-by-shetia-2/](https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/shen-du-you-xian-sou-suo-by-shetia-2/)

```
const rightSideView = function(root) {
  let res = []
  const dfs = function(root, depth) {
    if (root === null) return;
    if (depth === res.length) {
      res.push(root.val);
    }
    dfs(root.right, depth + 1);
    dfs(root.left, depth + 1);
  }
  dfs(root, 0);
  return res
};

```

## 198. 打家劫舍 

 [https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/](https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/)

```
// dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
var rob = function(nums) {
  if (nums === null || nums.length === 0) return 0;
  if (nums.length === 1) return nums[0];
  const dp = new Array(nums.length)
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);
  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
  }
  return dp[nums.length - 1];
};


var rob = function(nums) {
  if (nums === null || nums.length === 0) return 0;
  if (nums.length === 1) return nums[0];
  let dp_0 = nums[0];
  let dp_1 = Math.max(nums[0], nums[1]);
  for (let i = 2; i < nums.length; i++) {
    [dp_1, dp_0] = [Math.max(dp_1, dp_0 + nums[i]), dp_1];
  }
  return dp_1
};

```

##  剑指 Offer 29. 顺时针打印矩

## 236. 二叉树的最近公共祖先

```
var lowestCommonAncestor = function (root, p, q) {
  if (root == null) return null
  if (root == p || root == q) return root
  
  let left = lowestCommonAncestor(root.left, p, q)
  let right = lowestCommonAncestor(root.right, p, q)
  if (left != null && right != null) return root
  return left == null ? right : left
  if (left == null && right == null) return null
};

```

## 349. 两个数组的交集

[https://leetcode.cn/problems/intersection-of-two-arrays/solutions/1863891/by-carlsun-2-64px/?orderBy=hot&languageTags=javascript](https://leetcode.cn/problems/intersection-of-two-arrays/solutions/1863891/by-carlsun-2-64px/?orderBy=hot&languageTags=javascript)

## 31. 下一个排列  brain snap

[https://leetcode.cn/problems/next-permutation/solutions/479324/jie-fa-hen-jian-dan-jie-shi-qi-lai-zen-yao-jiu-na-/?orderBy=hot&languageTags=javascript](https://leetcode.cn/problems/next-permutation/solutions/479324/jie-fa-hen-jian-dan-jie-shi-qi-lai-zen-yao-jiu-na-/?orderBy=hot&languageTags=javascript)

视频 [https://www.bilibili.com/video/BV1dT4y1y78u/?spm_id_from=333.337.search-card.all.click&vd_source=084339227f2ecedefe3d00a33ffbfe32](https://www.bilibili.com/video/BV1dT4y1y78u/?spm_id_from=333.337.search-card.all.click&vd_source=084339227f2ecedefe3d00a33ffbfe32)

```
var nextPermutation = function(nums) {
  let i = nums.length - 2;
  while (i >= 0 && nums[i] >= nums[i+1]){
    i--
  }
  if (i >= 0){
    let j = nums.length - 1; 
    while (j >= 0 && nums[j] <= nums[i]){
      j--
    }
    [nums[j], nums[i]] = [nums[i], nums[j]]
  }
  let l = i + 1;
  let r = nums.length - 1;
  while (l < r){
    [nums[l], nums[r]] = [nums[r], nums[l]]
    l++
    r--
  }
}

```

## 1556. 千位分隔数

```
var thousandSeparator = function(n) {
    let result = [], count = 0, string = n + '';
    for(let i = string.length - 1; i >=0; i--) {
        result.unshift(string[i]); // unshift将元素添加到数组的开头
        count += 1;
        // 计数器数到3，同时判断不是最后一次遍历，若是最后一次的话不用加 . 的
        if(count === 3 && i) {
            result.unshift('.');
            count = 0; // 计数器重置为0
        }
    }
    return result.join('')
};

作者：Bertil
链接：
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

## 101. 对称二叉树

```
var isSymmetric = function(root) {
  if (!root) return true;
  // 左右节点是否对称
  const dfs = function(left, right) {
    if (!left && !right) {
      return true;
    } else if (left && right) {
      return left.val === right.val && dfs(left.left, right.right) && dfs(left.right, right.left);
    } else {
      return false;
    }
  }
  return dfs(root.left, root.right);
}; 

```

## 429. N叉树的层序遍历

```
var levelOrder = function(root) {
  if (root === null) return [];
  const stak = [root];
  let len = stak.length;
  let temp = [];
  let res = [];
  for (let i = 0; i < len;) {
    let shift = stak.shift();
    temp.push(shift.val);
    if (shift.children) {
      stak.push(...shift.children);
    }
    i++;
    if (i === len) {
      len = stak.length;
      res.push(temp);
      temp = [];
      i = 0;
    }
  }
  return res;
};

```

## 151. 翻转字符串里的单词

[https://leetcode.com/problems/reverse-words-in-a-string/discuss/47720/Clean-Java-two-pointers-solution-(no-trim(-)-no-split(-)-no-StringBuilder)](https://leetcode.com/problems/reverse-words-in-a-string/discuss/47720/Clean-Java-two-pointers-solution-(no-trim(-)-no-split(-)-no-StringBuilder))

```
  void reverseWords(char[] a, int n) {
    int i = 0, j = 0;
      
    while (j < n) {
	// 为什么什么要加一个i < len ？防止i越界，cant not read undefined

      while (i < j || i < n && a[i] == ' ') i++; // skip spaces
      while (j < i || j < n && a[j] != ' ') j++; // skip non spaces
      reverse(a, i, j - 1);                      // reverse the word
    }
  }
  
  // trim leading, trailing and multiple spaces
  String cleanSpaces(char[] a, int n) {
    int i = 0, j = 0;
      
    while (j < n) {
      while (j < n && a[j] == ' ') j++;             // skip spaces
      while (j < n && a[j] != ' ') a[i++] = a[j++]; // keep non spaces
      while (j < n && a[j] == ' ') j++;             // skip spaces
      if (j < n) a[i++] = ' ';                      // keep only one space
    }
  
    return new String(a).substring(0, i);
  }

```

## 230. 二叉搜索树中第K小的

```
  2
1   4
// 左边有没有
// 中间有没有
// 右边有没有

var kthLargest = function (root, k) {
  // 反中序遍历，记录数值第k个值返回
  let num = 0
  let result = null
  dfs(root)
  return result
    
    
  const dfs = function (node) {
    if (node === null) {
      return
    }
    dfs(node.right)
    num++
    if (num === k) {
      result = node.val
      return
    }
    dfs(node.left)
  }
  
};


```

## 40. 组合总和 II

原理 [https://leetcode.cn/problems/combination-sum-ii/solutions/14753/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/comments/225211/](https://leetcode.cn/problems/combination-sum-ii/solutions/14753/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/comments/225211/)

代码 [https://leetcode.cn/problems/combination-sum-ii/solutions/857552/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ig29/](https://leetcode.cn/problems/combination-sum-ii/solutions/857552/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-ig29/)

```
var combinationSum2 = function(candidates, target) {
    const res = []; path = [], len = candidates.length;
    candidates.sort((a,b)=>a-b);
    backtracking(0, 0);
    return res;
    function backtracking(sum, i) {
        if (sum === target) {
            res.push(Array.from(path));
            return;
        }
        for(let j = i; j < len; j++) {
            const n = candidates[j];
            if(j > i && candidates[j] === candidates[j-1]) continue;
            if(n > target - sum) break;
            path.push(n);
            sum += n;
            backtracking(sum, j + 1);
            path.pop();
            sum -= n;
        }
    }
};

```

## 227. 基本计算器 II long

[https://leetcode.cn/problems/basic-calculator-ii/solutions/648954/zui-hou-du-bian-cheng-zuo-jia-fa-leetcod-oxx9/?orderBy=hot&languageTags=javascript](https://leetcode.cn/problems/basic-calculator-ii/solutions/648954/zui-hou-du-bian-cheng-zuo-jia-fa-leetcod-oxx9/?orderBy=hot&languageTags=javascript)

```
var calculate = function(s) {
	const nums = []
	let cur = 0
	let prevOp = '+'
	s = s + '+'
	
	for (let i = 0; i < s.length; i++) {
		if (s[i] >= '0' && s[i] <= '9') {
			cur = cur * 10 + s[i].charCodeAt(0) -'0'.charCodeAt(0)
		} else if (s[i] == ' ') {
			continue
		} else {
			if (prevOp == '+') { 
                nums.push(cur)
            } else if (prevOp == '-') {
                nums.push( -1 * cur) 
            } else if (prevOp == '*') {
                nums[nums.length - 1] *=  cur 
            } else if (prevOp == '/') {
                nums[nums.length - 1]  =  (nums[nums.length - 1] / cur) | 0
            }
            prevOp = s[i] 
            cur = 0 
		}
	}
    let sum = 0
    nums.forEach(v => {
        sum += v
    })
    return sum
};

作者：笨猪爆破组
链接：
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

## 24. 两两交换链表中的节点

[https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/7058/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/](https://leetcode.cn/problems/swap-nodes-in-pairs/solutions/7058/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/)

```
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode next = head.next;
        head.next = swapPairs(next.next);
        next.next = head;
        return next;
    }
}

作者：画手大鹏
链接：
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

## 71. 简化路径

[https://leetcode.cn/problems/simplify-path/solutions/38868/71-simplify-path-ti-jie-javascript-by-raymond-yan/](https://leetcode.cn/problems/simplify-path/solutions/38868/71-simplify-path-ti-jie-javascript-by-raymond-yan/)

```
var simplifyPath = function(path) {
    const stack = [];
    const pathArr = path.split('/');
    
    for (let item of pathArr) {
        if (item === '' || item === '.') {
            continue;
        } else if (item === '..') {
            stack.pop();
        } else {
            stack.push(item);
        }
    }

    return '/' + stack.join('/');
};

作者：raymond-yan
链接：
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

## 122. 买卖股票的最佳时机 II

```
例子： [7,1,5,3,6,4]

// 每天看，如果有收益就买入卖出，如果为负保持观望
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result=0;
        for(int i=1;i<prices.size();i++)
            result = max(result+prices[i]-prices[i-1],result);
        return result;
    }
};

```

## 1143. 最长公共子序列

[https://leetcode.cn/problems/longest-common-subsequence/solutions/1143279/1143-zui-chang-gong-gong-zi-xu-lie-by-ch-isr3/?orderBy=hot&languageTags=javascript](https://leetcode.cn/problems/longest-common-subsequence/solutions/1143279/1143-zui-chang-gong-gong-zi-xu-lie-by-ch-isr3/?orderBy=hot&languageTags=javascript)

## 剑指 Offer 09. 用两个栈实 类

[https://leetcode.cn/problems/implement-queue-using-stacks/solutions/1143372/232-yong-zhan-shi-xian-dui-lie-by-chen-w-fmur/](https://leetcode.cn/problems/implement-queue-using-stacks/solutions/1143372/232-yong-zhan-shi-xian-dui-lie-by-chen-w-fmur/)

## 9. 回文数

```
var isPalindrome = function(x) { 
  if (x < 0 ) return false;
  let reverse = 0;
  let origin = x;
  while (origin) {
    reverse = reverse * 10 + origin % 10;
    origin = Math.floor(origin / 10);
  }
  return reverse === x;
};

```

## 394. 字符串解码

[https://leetcode.cn/problems/decode-string/solutions/264879/zhan-de-ji-yi-nei-ceng-de-jie-ma-liao-bie-wang-lia/](https://leetcode.cn/problems/decode-string/solutions/264879/zhan-de-ji-yi-nei-ceng-de-jie-ma-liao-bie-wang-lia/)

```
s = "3[a2[c]]"


```

## 169. 多数元素 brain snap

[https://leetcode.cn/problems/majority-element/solutions/1118909/169-duo-shu-yuan-su-by-chen-wei-f-imuv/](https://leetcode.cn/problems/majority-element/solutions/1118909/169-duo-shu-yuan-su-by-chen-wei-f-imuv/)

```
const majorityElement = nums => {
    let count = 1;
    let majority = nums[0];
    for (let i = 1; i < nums.length; i++) {
        if (count === 0) {
            majority = nums[i];
        }
        if (nums[i] === majority) {
            count++;
        } else {
            count--;
        }
    }
    return majority;
};

作者：晨
链接：
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

## 498. 对角线遍历 模拟

```
      1
    4   2
  7   5   3
    8   6
      9

```

```
public int[] findDiagonalOrder(int[][] matrix) {
    if (matrix == null || matrix.length == 0) {
        return new int[]{};
    }
    int r = 0, c = 0;
    int row = matrix.length, col = matrix[0].length;
    int[] res = new int[row * col];
    for (int i = 0; i < res.length; i++) {
        res[i] = matrix[r][c];
        // r + c 即为遍历的层数，偶数向上遍历，奇数向下遍历
        if ((r + c) % 2 == 0) {
            if (c == col - 1) {
                // 往下移动一格准备向下遍历
                r++;
            } else if (r == 0) {
                // 往右移动一格准备向下遍历
                c++;
            } else {
                // 往上移动
                r--;
                c++;
            }
        } else {
            if (r == row - 1) {
                // 往右移动一格准备向上遍历
                c++;
            } else if (c == 0) {
                // 往下移动一格准备向上遍历
                r++;
            } else {
                // 往下移动
                r++;
                c--;
            }
        }
    }
    return res;
}

```

## 468. 验证IP地址 	long

##  剑指 Offer 54. 二叉搜索树

```
  2
1   4
// 右边有没有
// 中间有没有
// 左边有没有

var kthLargest = function (root, k) {
  // 反中序遍历，记录数值第k个值返回
  let num = 0
  let result = null
  dfs(root)
  return result
    
    
  const dfs = function (node) {
    if (node === null) {
      return
    }
    dfs(node.right)
    num++
    if (num === k) {
      result = node.val
      return
    }
    dfs(node.left)
  }
  
};


```

## 78. 子集

```
「手画图解」简单问题细致分析，两种DFS回溯思路 | 78.子集

来自 <


```

```
var subsets = function(nums) {
  let res = []
  function dfs(idx, path) {
    // if (idx === path.length) {
    if (idx === nums.length) {
      res.push(path.slice())
      return 
    }
    path.push(nums[idx])
    dfs(idx + 1, path)
    path.pop()
    dfs(idx + 1, path)
  }
  dfs(0,[])
  return res
};

```

## 113. 路径总和 II  

```
var pathSum = function(root, sum) {
    let arr = [];
    let path = [];
    dfs(root,  path, arr, sum);
    return arr;
};

function dfs(root, path, arr, sum) {
    if(!root) return;
    path.push(root.val);
    if(root.val == sum && root.left == null && root.right == null) {
        arr.push(path.slice());
    }
    dfs(root.left, path, arr, sum - root.val);
    dfs(root.right, path, arr, sum - root.val);
    path.pop();
}


  

两种树，两种情况
  5                 5
4   8             4   8
                11 23
节点5不需要pop    节点4需要pop	 
	


  

```

##  179. 最大数  brain snap

```
var largestNumber = function(nums) {
    nums = nums.sort((a, b) => {
        let S1 = `${a}${b}`;
        let S2 = `${b}${a}`;
        return S2 - S1;
    });
    return nums[0] ? nums.join('') : '0';
};

作者：caoyq0521
链接：
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

##  110. 平衡二叉树

```
// 一个二叉树<每个节点>的左右两个子树的高度差的绝对值不超过 1 。
var isBalanced = function(root) {
  if (root === null) return true;
  if (Math.abs(rootHeight(root.left, 0) - rootHeight(root.right, 0)) <= 1) {
    return isBalanced(root.left) && isBalanced(root.right);
  } else {
    return false;
  }
    
  // 树深度
  function rootHeight(root, h) {
    if (root === null) return h;
    if (root) h++;
    return Math.max(rootHeight(root.left, h), rootHeight(root.right, h));
  }
};


```

# 热题100

## 55. 跳跃游戏 不懂

[https://leetcode.cn/problems/jump-game/solutions/1143641/tan-xin-dong-tai-gui-hua-dong-hua-tu-jie-47ie/](https://leetcode.cn/problems/jump-game/solutions/1143641/tan-xin-dong-tai-gui-hua-dong-hua-tu-jie-47ie/)

```
var canJump = function (nums) {
    if (nums.length === 1) return true; //长度为1 直接就是终点
    let cover = nums[0]; //能覆盖的最远距离
    for (let i = 0; i <= cover; i++) {
        cover = Math.max(cover, i + nums[i]); //当前覆盖距离cover和当前位置加能跳跃的距离中取一个较大者
        if (cover >= nums.length - 1) {
            //覆盖距离超过或等于nums.length - 1 说明能到达终点
            return true;
        }
    }
    return false; //循环完成之后 还没返回true 就是不能达到终点
};

```

## 221. 最大正方形 

代码 [https://leetcode.cn/problems/maximal-square/solutions/239915/jser-by-hyj8/](https://leetcode.cn/problems/maximal-square/solutions/239915/jser-by-hyj8/)

图画 [https://leetcode.cn/problems/maximal-square/solutions/44586/li-jie-san-zhe-qu-zui-xiao-1-by-lzhlyle/](https://leetcode.cn/problems/maximal-square/solutions/44586/li-jie-san-zhe-qu-zui-xiao-1-by-lzhlyle/)

```
正方形最大边长 = Math.min(左正方形最大边长，上正方形最大边长，左上正方形最大边长) + 1

```

## 39. 组合总和

```
var combinationSum = function (candidates, target) {
  const res = [];
  const temp = [];
  let sum = 0;
  dfs(0, 0);
  return res;


  function dfs(sum, start) {
    if (sum === target) {
        res.push(temp.slice());
      }
    for (let i = start; i < candidates.length; i++) {
      if (sum < target) {
        temp.push(candidates[i]);
        dfs(sum + candidates[i], i);
        temp.pop();
      } 
    }
  };

};

```

## 34. 在排序数组中查找元素 不懂

```
[5,7,7,8,8,10] 8

```

```
public int[] searchRange(int[] nums, int target) {
        double left = target - 0.5, right = target + 0.5;
        int l = bs(nums, left), r = bs(nums, right);
        if (l < r)return [l, r - 1];
        else return [-1, -1];
}
    
public int bs(int[] nums, double target) {
        int l = 0, h = nums.length-1;
        while(l <= h){
            int m = l + (h - l)/2;
            if(target > nums[m]) l = m+1;
            else h = m-1;
        }
        return l;
}

```

# TOP200

```
高频40

```

# 最全的手写JS面试题

## 1 compose

```
function compose(...fn) {
    return fn.reduce((pre, cur) => {
        return (...x) => pre(cur(...x))
    }}
}

```

## 3 发布订阅模式

```
class myEventEmitter {
  constructor() {
    this.events = {};
  }
  on(type, handler) {
    this.events[type] ? this.events[type].push(handler) : (this.events[type] = [handler]);
  }
  off(type, handler) {
    this.events[type] && this.events[type].filter((cur) => cur === handler);
  }
  emit(type, ...args) {
    this.events[type] &&
      this.events[type].forEach((cur) => {
        cur.apply(this, args);
      });
  }
  once(type, handler) {
    function fn(...args) {
      handler.apply(this, args);
      this.off(type, handler);
    }
    this.on(type, fn);
  }
}


```

## 4 数组去重

```
function unique(ary) {
  return Array.from(new Set(ary));
}

function unique(arr) {
  return arr.filter((item, index, array) => {
    return array.indexOf(item) === index;
  });
}
function unique(ary) {
  let i = 0;
  for (let j = 1; j < ary.length; j++) {
    if (ary[j] !== ary[i]) {
      i++;
      ary[i] = ary[j];
    }
  }
  ary.length = i + 1;
  return ary;
}




```

## 5 数组扁平化

```
function flatten(ary, depth = 1) {
  if (depth > 0) {
    return ary.reduce((pre, cur) => {
      return pre.concat(Array.isArray(cur) ? flatten(cur, depth - 1) : cur);
    }, []);
  } else {
    return ary.slice();
  }
}

[1, [2, [3]]];
function flatter(ary) {
  while (
    ary.some((cur) => {
      return Array.isArray(cur);
    })
  ) {
    [].concat(...ary);
  }
}




```

## 6 寄生组合继承

```
// 寄生组合继承
function Parent(value) {
  this.val = value;
}

function Child(value) {
  Parent.call(this, value);
}

Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});


```

```
// class继承
class Parent {
  constructor(value) {
    this.val = value;
  }
}

class Child extends Parent {
  constructor(value) {
    super(value);
    this.val = value;
  }
}

```

```
// 组合继承
function Parent (name) {
    this.name = name;
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
调用父级构造函数来继承原型，所以实例原型上出现了重复的父级构造函数的属性。

```

## 7 实现有并行限制的 Promise 调度器

## 8 new 操作符

```
function myNew(con, ...args) {
  const obj = Object.create(con.prototype);
  const res = con.apply(obj, ...args);
  return res instanceof Object ? res : obj;
}


```

## 9 call apply bind

```
Function.prototype.call = function (thisArg, ...args) {
  const fn = Symbol();
  thisArg = thisArg || window;
  thisArg[fn] = this;
  const res = thisArg[fn](...args);
  delete thisArg[fn];
  return res;
};
Function.prototype.myApply = function (thisArg, ary) {
  const fn = Symbol();
  thisArg = thisArg || window;
  thisArg[fn] = this;
  let res;
  if (ary) {
    res = thisArg[fn](...ary);
  } else {
    res = thisArg[fn]();
  }
  delete thisArg[fn];
  return res;
};
Function.prototype.myBind = function (thisArg, ...fixedArgs) {
  const _this = this;
  return function f(...args) {
    if (this instanceof f) {
      return new _this(...fixedArgs.concat(args));
    } else {
      return _this.apply(thisArg, args.concat(fixedArgs));
    }
  };
};


Function.prototype.myCall = function (context, ...args) {
	const fn = Symbol();
    this.fn = context;
    
}

```

## 10 深拷贝（考虑到复制 Symbol 类型）

```
function cloneDeep(obj, map = new Map()) {
  if (!(obj instanceof Object)) return obj;
	// 循环引用，就是指向相同的内存地址，也就是同一个obj(循环引用）
  if (map.has(obj)) return map.get(obj);
  const res = obj instanceof Object ? {} : [];
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      res[key] = deepClone(obj[key], map.set(obj, res));
    }
  }
  return res;
}

```

## 11 instanceof

```
// 判断对象的原型链上是否存在构造函数的prototype
function myInstanceof(left, right) {
  while (true) {
    if (left === null) return false;
    if (left.__proto__ === right.prototype) return true;
    left = left.__proto__;
  }
}

```

## 12 柯里化

## 19 实现 LazyMan

```
class _LazyMan {
  constructor(name) {
    this.tasks = [];
    const task = () => {
      console.log(`Hi! This is ${name}`);
      this.next();
    };
    this.tasks.push(task);
    // 把所有任务加进队列后执行一次next运行代码
    setTimeout(() => {
      this.next();
    }, 0);
  }
  next() {
    const task = this.tasks.shift(); // 取第一个任务执行
    task && task();
  }
  sleep(time) {
    this._sleepWrapper(time, false);
    return this; // 链式调用
  }
  sleepFirst(time) {
    this._sleepWrapper(time, true);
    return this;
  }
  _sleepWrapper(time, first) {
    const task = () => {
      setTimeout(() => {
        console.log(`Wake up after ${time}`);
        this.next();
      }, time * 1000);
    };
    if (first) {
      this.tasks.unshift(task); // 放到任务队列顶部
    } else {
      this.tasks.push(task); // 放到任务队列尾部
    }
  }
  eat(name) {
    const task = () => {
      console.log(`Eat ${name}`);
      this.next();
    };
    this.tasks.push(task);
    return this;
  }
}
function LazyMan(name) {
  return new _LazyMan(name);
}


```

## 20 防抖节流

```
// 防抖
function debounce(fn, delay = 300) {
  //默认300毫秒
  let timer;
  
  return function () {
    const args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args); // 改变this指向为调用debounce所指的对象
    }, delay);
  };
}

window.addEventListener(
  "scroll",
  debounce(() => {
    console.log(111);
  }, 1000)
);


function throttle(fn, delay) {
	let _this, _args;
    let flag = false;
    return function(...args) {
        _this = this;
        _args = args;
        if (flag) {
            return;
        }
        flag = true;
		setTimeout(() => {
            fn.apply(_this, _args);
            flag = false;
        }, time)
    }
}


window.addEventListener(
  "scroll",
  throttle(() => {
    console.log(111);
  }, 1000)
);

```

## 23 Promise 以及相关方法的实现

```
Promise.prototype.resolve2 = function (value) {
  return new Promise((resolve) => {
    resolve(value);
  });
};

Promise.prototype.reject2 = function (reason) {
  return new Promise((resolve, reject) => {
    reject(reason);
  });
};

//!  等待所有都完成（或第一个失败）。
//!  返回promise;
Promise.prototype.all = function (promises) {
  return new promises((resolve, reject) => {
    // ==========================
    // 异步或同步操作代码；
    let result = [];
    let resolved = 0;
    if (promises.length) {
      for (let i = 0; i < promises.length; i++) {
        Promise.resolve(promises[i]).then(
          (val) => {
            result[i] = val;
            resolved++;
            if (resolved === promises.length) {
              resolve(result); //异步操作执行成功后的回调函数
            }
          },
          (err) => {
            reject(err); //异步操作执行失败后的回调函数
          }
        );
        // ==========================
      }
    } else {
      resolve([]);
    }
  });
};

Promise.all = function (ps) {
	return new Promise((resolve, reject) => {
        const res = [];
        if (ps.length === 0) resolve(res);
        for (let i = 0; i < ps.length; i++) {
            Promise.resolve(ps[i]).then(response => {
               res[i] = response;
                if (res.length === ps.length) {
                    resolve(response);
                }
            }, error => {
                reject(error);
            })
        }
    })
}
//!  等待所有都失败（或第一个成功）。
//!  返回promise;
Promise.any = function (promises) {
  return new Promise((resolve, reject) => {
    // ==========================
    // 异步或同步操作代码；
    let result = [];
    let rejected = 0;
    if (promise.length === 0) {
      resolve([]);
    }

    for (let i = 0; i < promises.length; i++) {
      Promise.resolve(promises[i]).then(
        (value) => {
          resolve(value);
        },
        (reason) => {
          result[i] = reason;
          rejected++;
          if (rejected === promises.length) {
            reject(new AggregateError(result));
          }
        }
      );
      // ==========================
    }
  });
};

Promise.allSettled = function (promises) {
  return new Promise((resolve) => {
    let result = [];
    let settled = 0;
    if (promises.length === 0) {
      resolve([]);
    }
    for (let i = 0; i < promises.length; i++) {
      promises[i].then(
        (val) => {
          result[i] = {
            value,
            status: 'fulfilled',
          };
          settled++;
          if (settled == promises.length) {
            resolve(result);
          }
        },
        (reason) => {
          result[i] = {
            reason,
            status: 'rejected',
          };
          settled++;
          if (settled == promises.length) {
            resolve(result);
          }
        }
      );
    }
  });
};

//!  最先执行完的运行resolve or reject;
Promise.prototype.race = function (promises) {
  return new Promise((resolve, reject) => {
    if (promises.length === 0) {
      resolve();
    }
    for (let promise of promises) {
      promise.then(resolve, reject);
    }
  });
};

//!  onFinally成功 穿透
//!  onFinally失败 失败抛出自己的reason
Promise.prototype.finally = function (onFinally) {
  return this.then(
    //!  onFinally()
    //!  穿透
    (value) => Promise.resolve(onFinally()).then(() => value),
    (reason) =>
      Promise.resolve(onFinally()).then(() => {
        throw reason;
      })
  );
};





```

## 24 实现一个 add 方法

```
function add(...args) {
  var f = add.bind(null /*this不用绑定*/, ...args);
  f.toString = () => {
    return args.reduce((a, b) => a + b);
  };
  return f;
}
add(1)(2)(3) + 1;

// 来自 <

```

## 30 分片思想解决大数据量渲染问题

## 33 实现一个对象的 flatten 方法

```
const obj = {
 a: {
        b: 1,
        c: 2,
        d: {e: 5}
    },
 b: [1, 3, {a: 2, b: 3}],
 c: 3
}

function flattenObj(obj) {
  const res = {};
  for (let key in obj) {
        dfs(res, obj[key], `${key}`)
  }
  return res;

  function dfs(res, obj, prefix) {
    if (Array.isArray(obj)) {
      obj.forEach((cur, idx) => {
        dfs(res, cur, prefix + '[' + idx +']')
      })
    } else if (typeof obj === 'object') {
       for (let [key, val] of Object.entries(obj)) {
        dfs(res, val, prefix + '.' + key)
      }
    } else {
      res[prefix] = obj;
    }
  }
}

let newObj = flattenObj(obj)

```

## 34 列表转成树形结构

```
let a = [
    {
        id: 1,
        text: '节点1',
        parentId: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        parentId: 1 //通过这个字段来确定子父级
    }

]



function listToTree(list) {
  const temp = {};
  const res = [];
  for (let val of list) {
    temp[val.id] = val;
  }
  for (const [key, val] of Object.entries(temp)) {
    if (val.parentId !== 0) {
      !temp[val.parentId].children && (temp[val.parentId].children = []);
      temp[val.parentId].children.push(val);
    } else {
      res.push(val);
    }
  }
  return res;
}

let b = listToTree(a);

```

## Reduce

```
Object.prototype.myReduce = function (f, initial) {
  let total = initial || this[0];
  for (let i = initial ? 0 : 1; i < this.length; i++) {
    total = f(total, this[i], i, this);
  }
  return total;
};

```